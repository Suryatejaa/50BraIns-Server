generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")      // Pooled connection
  directUrl = env("DIRECT_URL")        // Direct connection
}

model User {
  id                     String         @id @default(dbgenerated("(gen_random_uuid())::text"))
  email                  String         @unique
  username               String         @unique
  password               String?
  roles                  String[]       @default(["USER"])
  status                 String?        @default("PENDING_VERIFICATION")
  isActive               Boolean?       @default(true)
  emailVerified          Boolean?       @default(false)
  emailVerifiedAt        DateTime?      @db.Timestamptz(6)
  firstName              String?
  lastName               String?
  phone                  String?
  bio                    String?
  location               String?
  profilePicture         String?
  coverImage             String?
  instagramHandle        String?
  twitterHandle          String?
  linkedinHandle         String?
  youtubeHandle          String?
  website                String?
  contentCategories      String[]       @default([])
  primaryNiche           String?
  primaryPlatform        String?
  estimatedFollowers     Int?
  companyName            String?
  companyType            String?
  industry               String?
  gstNumber              String?
  companyWebsite         String?
  marketingBudget        String?
  targetAudience         String[]       @default([])
  campaignTypes          String[]       @default([])
  designationTitle       String?
  crewSkills             String[]       @default([])
  experienceLevel        String?
  equipmentOwned         String[]       @default([])
  portfolioUrl           String?
  hourlyRate             Int?
  availability           String?
  workStyle              String?
  specializations        String[]       @default([])
  twoFactorSecret        String?
  twoFactorEnabled       Boolean?       @default(false)
  passwordResetToken     String?
  passwordResetExpires   DateTime?      @db.Timestamptz(6)
  emailVerificationToken String?
  createdAt              DateTime?      @default(now()) @db.Timestamptz(6)
  updatedAt              DateTime?      @default(now()) @updatedAt @db.Timestamptz(6)
  lastLoginAt            DateTime?      @db.Timestamptz(6)
  lastActiveAt           DateTime?      @default(now()) @db.Timestamptz(6)
  lastUsernameUpdated    DateTime?      @db.Timestamptz(6)
  isBanned               Boolean?       @default(false)
  banReason              String?
  banExpiresAt           DateTime?      @db.Timestamptz(6)
  bannedAt               DateTime?      @db.Timestamptz(6)
  bannedBy               String?
  showContact            Boolean?       @default(false)
  adminLogs              AdminLog[]     @relation("AdminUser")
  targetedLogs           AdminLog[]     @relation("TargetUser")
  refreshTokens          RefreshToken[]

  @@index([email], map: "idx_auth_users_email")
  @@index([status], map: "idx_auth_users_status")
  @@index([username], map: "idx_auth_users_username")
  @@map("authUsers")
}

model RefreshToken {
  id         String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  token      String    @unique
  userId     String
  expiresAt  DateTime  @db.Timestamptz(6)
  createdAt  DateTime? @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime? @default(now()) @updatedAt @db.Timestamptz(6)
  lastUsedAt DateTime? @default(now()) @db.Timestamptz(6)
  ipAddress  String?
  userAgent  String?
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([expiresAt], map: "idx_auth_refresh_tokens_expires_at")
  @@index([userId], map: "idx_auth_refresh_tokens_user_id")
  @@map("authRefreshTokens")
}

model AdminLog {
  id        String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  adminId   String
  targetId  String?
  action    String
  details   Json?
  reason    String?
  ipAddress String?
  userAgent String?
  createdAt DateTime? @default(now()) @db.Timestamptz(6)
  admin     User      @relation("AdminUser", fields: [adminId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  target    User?     @relation("TargetUser", fields: [targetId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@map("authAdminLogs")
}

model OTPRecord {
  id        String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  email     String
  otpHash   String
  purpose   OTPPurpose
  userId    String?
  expiresAt DateTime  @db.Timestamptz(6)
  isUsed    Boolean   @default(false)
  usedAt    DateTime? @db.Timestamptz(6)
  attempts  Int       @default(0)
  createdAt DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt DateTime  @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([email, purpose], map: "idx_otp_email_purpose")
  @@index([expiresAt], map: "idx_otp_expires_at")
  @@index([isUsed], map: "idx_otp_is_used")
  @@map("authOTPRecords")
}


enum roles {
  USER
  INFLUENCER
  BRAND
  CREW
  MODERATOR
  ADMIN
  SUPER_ADMIN
}

enum Status {
  PENDING_VERIFICATION
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
}

enum OTPPurpose {
  REGISTER
  LOGIN
  FORGOT_PASSWORD
  CHANGE_PASSWORD
  EMAIL_VERIFICATION
  EMAIL_UPDATE
}

